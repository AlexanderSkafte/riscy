--------------------------------------------------------------------------------
IMPORTANT NOTES
--------------------------------------------------------------------------------

This file is in dire need of an update. I will do it when the code is better.

Some notes:

	- The data must come first in the program
	- After the data comes the text segment i.e. the instructions
	- The first line of the resulting binary file tells the interpreter on
	  which line the instruction header lies.
	- The instruction header contains the line number that comes after
	  the last instruction

	- The registers can hold 16-bit integers. Internally they are stored as
	  unsigned integers (uint16_t from stdint.h) but can be printed as
	  hexadecimal, signed or unsigned integers.


--------------------------------------------------------------------------------
	The stack and the heap 
--------------------------------------------------------------------------------

Global variables, i.e. those declared after the .data directive, are stored
on the heap, i.e. at memory addresses starting from 0 and growing upward.

The stack pointer, sp, is a variable that keeps track of the top of the stack,
i.e. the lowest address in a block (the stack grows downward).

At start-up, the stack pointer has a value of 255 (MEMORY_SIZE - 1). To make
room on the stack for more variables, use



--------------------------------------------------------------------------------
	Labels
--------------------------------------------------------------------------------

Labels, i.e. those declared such as "loop:", must be at the beginning of a line
and end with a colon character (':').

A label may not contain only digits.

When the assembler first encounters a label, it will associate the label name
with a an address, i.e. an integer that is stored on the heap.



--------------------------------------------------------------------------------
	Registers
--------------------------------------------------------------------------------

There are eigth registers, r0 to r7. To make things work, there are some
conventions that shall always be followed when implementing the VM for this ISA.

r0	-	Zero register; The contents of this register is always 0.

r1-r5	-	General purpose registers; can be used for any purpose.
		Examples are arguments to function call, return values from
		function calls, etc.

r6	-	Stack pointer; the contents of this register is the highest
		memory address.

r7	-	Return address; use like >> jalr r7, rX << where rX contains the
		address of the routine to jump to.



--------------------------------------------------------------------------------
	Instruction set
--------------------------------------------------------------------------------

In total, there are 8 instructions, represented by 3 bits each:

opcode	name	format		example usage 1		example usage 2
--------------------------------------------------------------------------------
000	add	RRR		add	r1, r2, r3
001	addi	RRI		addi	r1, r2, 20	addi r1, r2, label
010	nand	RRR		nand	r1, r2, r3
011	lui	RI		lui	r1, 30
100	sw	RRI		sw	r1, r2, 0	sw r1, zero, label
101	lw	RRI		lw	r1, r2, 0	lw r1, zero, label
110	beq	RRI		beq	r1, r2, label
111	jalr	RRI		jalr	r7, r2

Format		...	  bits
------------------------------
RRR-type	opcode	: 3
		reg A	: 3
		reg B	: 3
		0	: 4
		reg C	: 3

RRI-type	opcode	: 3
		reg A	: 3
		reg B	: 3
		simm	: 7

RI-type		opcode	: 3
		reg A	: 3
		usimm	: 10

Pseudoinstructions (yet to be implemented):

	nop			=	add	r0, r0, r0
	lli	reg, simm	=	addi	reg, reg, imm & 0x3f
	movi	reg, imm	=	lui	reg, imm
					addi	reg, reg, imm & 0x3f

--------------------------------------------------------------------------------

mask:	.fill	0000000000111111
imm:	.fill	1010101010101010
result:	.fill	0000000000000000

	lw	r1, r0, imm
	lw	r2, r0, mask
	and	r1, r1, r2
	sw	r3, r0, result

<EQUALS>

	movi	r1, 
	lli	r1, 1111111
# ==
	lw	r1, r0, imm			# arg 1
	lw	r2, r0, mask			# arg 2
	lw	r3, r0, and			# r3 = address of AND routine
	jalr	r6, r3				# call AND routine
						# r3 == imm & 0x3f
	addi	r1, r1, r3

--------------------------------------------------------------------------------

#===============================================================================
#	MOVI
#===============================================================================

x003f:	.fill	0000000000111111

movi:
	lui	r1, rout			# r1 = &rout & 0xffc0
	lw	r2, r0, x003f			# r2 = 0x003f

	# ------------------------------------- # r3 = &rout | 0x003f
	addi	sp, sp, 1111110			# Make room for 2 on stack
	sw	r1, sp, 0000000			# Save r1
	sw	r2, sp, 0000001			# Save r2
	nand	r3, r1, r2			# ----\
	nand	r1, r1, r2			# AND  > r3 = r1 & r2
	nand	r3, r3, r1			# ----/
	lw	r1, sp, 0000000			# Restore r1
	lw	r2, sp, 0000001			# Restore r2
	addi	sp, sp, 0000010			# Remove room for 2 on stack

	addi	r1, r1, r3			# r1 |= r3 (== &rout | 0x003f)
						# OR the bottom 6 bits of &rout
						# into r1

	jalr	r6, r1				# Call rout
	beq	r0, r0, end:			# Quit program

rout:	addi	r5, r0, 0100101			# r5 = 37
	jalr	r0, r6				# Return

end:	add	r0, r0, r0			# nop

#===============================================================================


rout:	<instructions>
	<instructions>
	<instructions>

## new
	movi	r1, 
	lli	r1, 1111111
# ==
	lw	r1, r0, imm			# arg 1
	lw	r2, r0, mask			# arg 2
	lw	r3, r0, and			# r3 = address of AND routine
	jalr	r6, r3				# call AND routine
						# r3 == imm & 0x3f

--------------------------------------------------------------------------------
	Example usage
--------------------------------------------------------------------------------

################################################################################
#	and (r1, r2) -> r3
#	- r3 = r1 & r2
#	- r3 is not preserved
################################################################################

and:	addi	r7, r7, 1111110			# Stack pointer -= 2
	sw	r1, sp, 0000000			# Save r1
	sw	r1, sp, 0000001			# Save r2
	nand	r3, r1, r2			# r3 = ~(r1 & r2)
	nand	r1, r1, r2			# r4 = ~(r1 & r2)
	nand	r3, r3, r1			# r5 = ~(r3 & r4)
	lw	r1, sp, 0000000			# Restore r1
	lw	r2, sp, 0000001			# Restore r2
	addi	r7, r7, 0000011			# Stack pointer += 2

	jalr	r0, r6

################################################################################







